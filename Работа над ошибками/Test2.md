# Работа над ошибка для 2теста

## Оглавление

* [Затенение переменных внутри цикла fori](#question1)
* [Обработка исключений](#question2)
* [Использование переменных интерфейса](#question3)
* [xxx](#question)
* [xxx](#question)
* [xxx](#question)
* [xxx](#question)
* [xxx](#question)

## Затенение переменных внутри цикла fori

<a name="question1"></a>

При декларировании цикла for стоит обратить особое внимание на объявление итерируемого значения. Если перед им ененм переменной указан тип, тогда в области видимости цикла ({}) будет выполнено затенение переменной с тем же именем, объявленной до цикла. **т.е. она НЕ будет изменена!**

### Пример

``` 

int j = 0
while (j < 5) {

    for (j = 0; j <= 5;) {
        System.out.println("inner J: " +j);
        j++;
    }
    System.out.println("outer J: " + j);
    j++;
}
```

В этом случае переменная все изменения j, произошедшие внутри цикла for не повлияют на переменную j, объявленную до цикла for.

## Обработка исключений

<a name="question2"></a>

При проверке возможности перехвата исключений обчзательно нужно обращать внимание на порядок следования блоков catch. Первым должно идти исключение самого узкого типа (child) и далее по мере расширения (от chaild к parent). В противном случае при компиляции будет определена ошибка "Недостижимый код":

 `java: exception testScope.MyException1 has already been caught`

## Использование переменных интерфейса

<a name="question3"></a>

Пееременные интерфейса имеют модификаторы:

 `public static final`

Определение значения в случае с переменной интерфейса (и другими final переменными) происходит на этапе компиляции, а не в рантайме, а тут динамический полиморфизм еще не работает, используется статический, который может определить значение переменной только по типу refType.
Другими словами, если refType

## Сигнатура методов при переопределении

<a name="question4"></a>

Есть несколько правил переопределения методов при наследовании.

Тут было нарушено одно из правил.

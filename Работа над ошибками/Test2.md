# Работа над ошибка для 2теста

## Оглавление

* [Затенение переменных внутри цикла fori](#question1)
* [Обработка исключений](#question2)
* [Использование переменных интерфейса](#question3)
* [переопределения методов (Overriding)](#question4)
* [Вычисление выражений](#question5)
* [Область видимости выражений](#question6)
* [Недостижимый код](#question7)

<a name="question1"></a>

## Затенение переменных внутри цикла fori

При декларировании цикла for стоит обратить особое внимание на объявление итерируемого значения. Если перед им ененм переменной указан тип, тогда в области видимости цикла ({}) будет выполнено затенение переменной с тем же именем, объявленной до цикла. **т.е. она НЕ будет изменена!**

### Пример

``` java

int j = 0
while (j < 5) {

    for (j = 0; j <= 5;) {
System.out.println("inner J: " +j);
j++;
    }
    System.out.println("outer J: " + j);
    j++;
}
```

В этом случае переменная все изменения j, произошедшие внутри цикла for не повлияют на переменную j, объявленную до цикла for.

<a name="question2"></a>

## Обработка исключений

При проверке возможности перехвата исключений обчзательно нужно обращать внимание на порядок следования блоков catch. Первым должно идти исключение самого узкого типа (child) и далее по мере расширения (от chaild к parent). В противном случае при компиляции будет определена ошибка "Недостижимый код":

 `java: exception testScope.MyException1 has already been caught`

<a name="question3"></a>

## Использование переменных интерфейса

Пееременные интерфейса имеют модификаторы:

 `public static final`

Определение значения в случае с переменной интерфейса (и другими final переменными) происходит на этапе компиляции, а не в рантайме, а тут динамический полиморфизм еще не работает, используется статический, который может определить значение переменной только по типу refType.
Другими словами, если refType

<a name="question4"></a>

## Правила переопределения методов

Есть несколько правил переопределения методов при наследовании.

Общий регламент переопределения:

1. Совпадение сигнатуры (наименование метода, типы и количество параметров)
1. Ковариантность возвращаемых типов. Переопределяемый метод может вернуть не только сам объект, но и его потомков.
1. Ковариантность выбрасываемых исключений. Переопределяемый метод может как не выбрасывать исключение, там и выбросить искллючение parent-метода или его потомков.
1. Последовательность доступа. private метод переопределить нельзя по причине его недоступности.

Пример по правилам:

``` java
class Parent {
    protected ReturnValue ExceptionsThrower() throws MyException {
return new ReturnValue();
    }
}
class Child extends Parent{
    public ChildReturnValue ExceptionsThrower() throws MyException2 {
return new ChildReturnValue();
    }
}

class ReturnValue{}
class ChildReturnValue extends ReturnValue{}

class MyException extends Exception {}
class MyException1 extends MyException {}
class MyException2 extends MyException1 {}
```

<a name="question5"></a>

## Вычисление выражений

Вычисление выражений выполняется слева направо.
т.е. в примере:

``` java
int i = 0;
int[] iA = {10, 20};
iA[i] = i = 30;

```

Последовательность вычислений `iA[i] = i = 30;` будет следующая:

1. `iA[i] = i = 30;`
1. `iA[0] = i = 30;`
1. `iA[0] = 30;`

<a name="question6"></a>

## Область видимости выражений

При решении задач, связанных с вычислением значений первое. на сто стоит обратить внимание наобласть видимости! Она определяется фигурными скобками {}. Несколько правил:

1. Переменные, объявленные внутри области видимости и имеющие такие же наименования как переменные вне - будет затенять внешние.
2. Особое внимание стоит уделять {}

<a name="question7"></a>

## Недостижимый код

При анализе выражений на предмет выявления ошибок компиляции следует искать участки недостижимого кода.
Например, следующее выражение содержит недостижимый код:

``` java
while(false) {
    //
}
```

А этот фрагмент уже будет компилироваться без проблем:

``` java
boolean b = false;
while(b) {
    //
}
```

 В то же время, стоит обратить внимание, что например следующий код будет компилироваться без проблем, т.к. недостижимого кода содержать не будет:

``` java
do {
    // other code
} while(false)
```
